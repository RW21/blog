<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Java並列化 | RW21 Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Java並列化" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="はじめに 本記事ではJavaにおける並列処理を主に個人の備忘録、勉強用として雑に記しています。気が向いたら更新します。主にJavaの並列化に使うキーワードを紹介しています。 並列処理 並列処理とは複数のスレッドを使って、メインスレッドとは別のスレッドでプロセスを行うことである。 並列処理における問題例 スレッドAがメモリを読み込んでいる間にスレッドBがそのメモリに書き込みをしたら、スレッドAで読み取られるのは新しい値か古い値か? 並列(concurrency) vs 並行(parallelism) 並列化と並行化という単語は同じマルチスレッドプログラミングにおいてよく使われますが、同一ではありません。 並列化 システムが複数のタスクを一度にこなすこと。 並行化 タスクがサブタスクに分散して一度に複数のサブタスクをこなすこと。 マルチスレッドプログラミング? 分散コンピューティング? 並行処理? 並列処理? マルチスレッドプログラミングや分散コンピューティングの概念は並列処理の概念とよく似ています。基本的には(並行処理, 並列処理)⊆マルチスレッディングです。本記事では並列処理しか扱いません。 なぜ並列処理するのか リソース利用の最適化 CPUのアイドルタイムを減らす。 プログラムの高速化 例えばサーバーからリクエストをlistenしてそのリクエストを処理するループがあるとする。 while(server is active){ // リクエストを受ける ... // リクエストを処理する } このループではリクエストを処理してる間は他のリクエストを受けれなくなっている。もしリクエストの処理のタスクを他のスレッドに受け渡せば、すぐにまたリクエストを受けれるようになり、高速化できる。 while(server is active){ // リクエストを受ける ... // リクエストを他スレッドに受け渡す } 主な並列処理モデル ここで紹介する並列処理モデルは分散コンピューティングシステムに使われるモデルと共通するのもあります。 Parallel Workers 出典: Jenkov.com Delegatorがworkerにタスクを分散する方法です。Parallel worker モデルは最もJavaの並列処理に使われているモデルです。java.util.concurrentパッケージに含まれているツールはこのモデルに基づいて作られています。 利点/欠点 利点 簡単 欠点 複数のworkerが同じメモリもしくはデータベースを改変している場合、workerスレッドはその改変が他のworkerスレッドにも知らされるようにしなければならない。(CPUの実行に留まらず、メモリにプッシュされなければならない) 競合状態やデッドロックといった並列処理におけるよくある問題を避けなければならない。 -スレッドが同じデータ構造へのアクセスを待ってしまうと並行化(parallelisation)が欠けてします。 タスクの順番が決定的ではない。これにより、現在のシステムのステートがどうなっているのか分からなくなる場合がある。 Assembly Line 出典: Jenkov.com Workerにタスクの役割があって、一つのタスクが終わると次のWorkerにタスクが移行する。 出典: Jenkov.com 上の図のようになることも。 利点/欠点 利点 共有ステートがない。 タスクに順番がある。 欠点 Same-threading シングルスレッドのプログラムを複数のCPUコアを活用するために複数コアに渡ってスケールすること。このモデルでは共有されるデータ構造、メモリはありません。 Javaでスレッドを作る Javaではスレッドはオブジェクトとして扱われています。 public class StartThread { public static void main(String[] args) { Thread myThread = new Thread(); myThread.start(); } } myThread.start();でスレッドを始めています。しかしこれではスレッドは何もしていません。 runメソッドをオーバーライドしてスレッドでコードを動かす スレッドに動くコードを指定するにはThreadのサブクラスを作り、runメソッドをオーバーライドします。 public class StartThread { public static class MyThread extends Thread { @Override public void run() { System.out.println(&quot;Hello World&quot;); } } public static void main(String[] args) { Thread myThread = new MyThread(); myThread.start(); } } Runnableインターフェースでスレッドを実装 Runnableをコンストラクタとして通してスレッドを作ることができます。 public class StartThread { public static class MyRunnable implements Runnable { @Override public void run() { System.out.println(&quot;Hello again&quot;); } } public static void main(String[] args) { Thread myThread1 = new Thread(new MyRunnable()); myThread1.start(); } } スレッドが取り得る状態 New スレッドが作られて、まだ実行(run)されていない状態。 Runnable スレッドが実行された状態。 Blocked 同期ブロックを実行待ち。(他のスレッドがすでに実行している。) Waiting 他のスレッドを待っている。スレッドシグナリングでWaitingになったり解除されたりする。 競合状態とクリティカルセクション 競合状態はクリティカルセクションで起こりうる状態です。 クリティカルセクション クリティカルセクションとはコードが複数のスレッドで実行されて、その順番によって結果が異なる状態です。複数のスレッドが同じクリティカルセクションに書き込みしようとすると問題が発生します。 public class Counter { protected long count = 0; public void add(long value){ this.count = this.count + value; } } 上記のクラスではaddメソッドがクリティカルセクションになります。 競合状態 上のクリティカルセクションを2つのスレッドAとBで実行されます。まずスレッドAとBがレジスターにthis.count = 0を読み込みます。まずスレッドAが読み込まれたthis.countに2を足します。その後、スレッドBが読み込まれたthis.countに3を足します。この場合、最終的な結果はthis.count = 5ではなく、this.count = 3になります。 上記のように複数のスレッドが同じリソースを取り合うことを競合状態といいます。 競合状態を防ぐ 競合状態を防ぐ一つの方法にはクリティカルセクションを不可分操作(atomic)状態にするというのがあります。つまり、一つのスレッドが実行中には他のスレッドが実行できない状態にします。 これを実現するにはクリティカルセクションでスレッド同期を行います。スレッド同期を行うこと以外ではスレッドロックやjava.util.concurrent.atomic.AtomicIntegerなどの不可分操作変数を使うことができます。 スレッドセーフと共有リソース 複数のスレッドに同時で実行されても安全なコードをスレッドセーフと呼びます。スレッドセーフなコードは競合状態を起こしません。競合状態は複数のスレッドが共有リソースをアクセスすることで起こります、なのでどういったリソースが共有なのかを知っておくことが大切です。 ローカル変数 ローカル変数はスレッドのスタックに保存されるのでスレッド間で共有されることがありません。プリミティブ型のローカル変数は常にスレッドセーフです。 ローカルオブジェクト参照 この場合は、参照自体は共有されません。しかしオブジェクトは共有ヒープに保存されます。もしオブジェクトがローカルで作成されメソッドの外には出ない場合、スレッドセーフです。 メンバ変数 メンバ変数はオブジェクトと共にヒープに保存されています。スレッドセーフではありません。 synchronizedキーワードで同期ブロック Javaの同期ブロックはすべてsynchronizedのメソッド修飾子で実装できます。 public synchronized void add(int value){ this.count += value; } メソッド全体を同期ブロックにするのが好ましくない場合は、一部だけ同期ブロックにすることができます。 public void add(int value){ synchronized(this){ this.count += value; } } 同期ブロックの中のコードは複数のスレッドで同時に実行されることはありません。 volatileキーワード Volatileとは揮発性という意味です。プログラミングにおいては値が変更されていないようにみえてもアクセスする度に変わっているという意味になります。Javaのvolatileキーワードは変数がCPUキャッシュにではなくメインメモリに保存されていることを保証をします。 例えば以下のような共有されている変数があるとします。 public class SharedObject { public int counter = 0; } スレッド1はcounterをインクリメントします。スレッド1とスレッド2は度々counterを読みます。もしcounterがvolatileだと宣言されていない場合は、メインメモリからではなく、CPUキャッシュから値が読まれる恐れがあります。以下の図がこのシチューションを表しています。 出典: Jenkov.com volatileだけでは十分じゃない場合 スレッドがvolatileな変数を読み込んで、それを元に新しい値に更新してしまうと、その変数は固定されるのを保証されません。変数を読み込んで書き込むまでの間に他のスレッドが書き込む可能性があり、競合状態が発生します。 ThreadLocal ThreadLocalクラスは一つのスレッドにしか読み書きできない変数を作るのに使います。もし2つのスレッドが同じThreadLocalの参照を読み込むと2つのスレッドは互いのThreadLocal変数にアクセスできません。 ThreadLocal変数の作成 private ThreadLocal myThreadLocal = new ThreadLocal(); ThreadLocal変数へのアクセス ThreadLocal変数が作成されると以下のように値を設定できます。 myThreadLocal.set(&quot;A thread local value&quot;); 値を読み込むには: String threadLocalValue = (String) myThreadLocal.get(); スレッドシグナリング スレッドシグナリングでスレッド間にシグナルを送ることができます。シグナリングを使えばスレッドが他のスレッドを待機するということができるようになります。 共有オブジェクトでシグナリング 共有変数の値を変更することでスレッド間のシグナリングを行うのが最も簡単です。 public class MySignal{ protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess(){ return this.hasDataToProcess; } public synchronized void setHasDataToProcess(boolean hasData){ this.hasDataToProcess = hasData; } } 出典: Jenkov.com wait() notify() notifyAll() java.lang.Objectにはシグナルを待機しているスレッドを非アクティブ化するメカニズムがあります。wait()をオブジェクトに呼び出すスレッドは他のスレッドがそのオブジェクトがnotify()を実行するまで非アクティブになります。 デッドロック デッドロックとは本来スレッドシグナリングで進行するはずの複数のスレッドがブロック状態(非アクティブ)になっていて、プログラムが動かない状態を指します。簡単な例をあげると、スレッドAとスレッドBがあって、スレッドAがスレッドBをロックしてスレッドBを待機する、スレッドBがスレッドAをロックしてスレッドAを待機する。 生産者消費者問題 並列処理の問題としてよく取り上げられるのが生産者消費者問題です。この問題では、一つのデータ構造から複数の消費者スレッドがアイテムを取り出し、複数の生産者がアイテムを追加します。 データ構造 データ構造は先に入れられたデータから順に取り出されるキューで実装します。 スレッド 消費者スレッドはキューがいっぱいになると生産者スレッドをブロックします。(これ以上商品を足すのを防ぐため。)逆に、生産者スレッドはキューが空になると消費者スレッドをブロックするよう実装します。 これらはいちいちスレッドシグナリングを実行しなくてもjava.util.concurrent.BlockingQueueで簡単に実装できてしまいます。 参照 Jenkov.com Java documentation Winterbe" />
<meta property="og:description" content="はじめに 本記事ではJavaにおける並列処理を主に個人の備忘録、勉強用として雑に記しています。気が向いたら更新します。主にJavaの並列化に使うキーワードを紹介しています。 並列処理 並列処理とは複数のスレッドを使って、メインスレッドとは別のスレッドでプロセスを行うことである。 並列処理における問題例 スレッドAがメモリを読み込んでいる間にスレッドBがそのメモリに書き込みをしたら、スレッドAで読み取られるのは新しい値か古い値か? 並列(concurrency) vs 並行(parallelism) 並列化と並行化という単語は同じマルチスレッドプログラミングにおいてよく使われますが、同一ではありません。 並列化 システムが複数のタスクを一度にこなすこと。 並行化 タスクがサブタスクに分散して一度に複数のサブタスクをこなすこと。 マルチスレッドプログラミング? 分散コンピューティング? 並行処理? 並列処理? マルチスレッドプログラミングや分散コンピューティングの概念は並列処理の概念とよく似ています。基本的には(並行処理, 並列処理)⊆マルチスレッディングです。本記事では並列処理しか扱いません。 なぜ並列処理するのか リソース利用の最適化 CPUのアイドルタイムを減らす。 プログラムの高速化 例えばサーバーからリクエストをlistenしてそのリクエストを処理するループがあるとする。 while(server is active){ // リクエストを受ける ... // リクエストを処理する } このループではリクエストを処理してる間は他のリクエストを受けれなくなっている。もしリクエストの処理のタスクを他のスレッドに受け渡せば、すぐにまたリクエストを受けれるようになり、高速化できる。 while(server is active){ // リクエストを受ける ... // リクエストを他スレッドに受け渡す } 主な並列処理モデル ここで紹介する並列処理モデルは分散コンピューティングシステムに使われるモデルと共通するのもあります。 Parallel Workers 出典: Jenkov.com Delegatorがworkerにタスクを分散する方法です。Parallel worker モデルは最もJavaの並列処理に使われているモデルです。java.util.concurrentパッケージに含まれているツールはこのモデルに基づいて作られています。 利点/欠点 利点 簡単 欠点 複数のworkerが同じメモリもしくはデータベースを改変している場合、workerスレッドはその改変が他のworkerスレッドにも知らされるようにしなければならない。(CPUの実行に留まらず、メモリにプッシュされなければならない) 競合状態やデッドロックといった並列処理におけるよくある問題を避けなければならない。 -スレッドが同じデータ構造へのアクセスを待ってしまうと並行化(parallelisation)が欠けてします。 タスクの順番が決定的ではない。これにより、現在のシステムのステートがどうなっているのか分からなくなる場合がある。 Assembly Line 出典: Jenkov.com Workerにタスクの役割があって、一つのタスクが終わると次のWorkerにタスクが移行する。 出典: Jenkov.com 上の図のようになることも。 利点/欠点 利点 共有ステートがない。 タスクに順番がある。 欠点 Same-threading シングルスレッドのプログラムを複数のCPUコアを活用するために複数コアに渡ってスケールすること。このモデルでは共有されるデータ構造、メモリはありません。 Javaでスレッドを作る Javaではスレッドはオブジェクトとして扱われています。 public class StartThread { public static void main(String[] args) { Thread myThread = new Thread(); myThread.start(); } } myThread.start();でスレッドを始めています。しかしこれではスレッドは何もしていません。 runメソッドをオーバーライドしてスレッドでコードを動かす スレッドに動くコードを指定するにはThreadのサブクラスを作り、runメソッドをオーバーライドします。 public class StartThread { public static class MyThread extends Thread { @Override public void run() { System.out.println(&quot;Hello World&quot;); } } public static void main(String[] args) { Thread myThread = new MyThread(); myThread.start(); } } Runnableインターフェースでスレッドを実装 Runnableをコンストラクタとして通してスレッドを作ることができます。 public class StartThread { public static class MyRunnable implements Runnable { @Override public void run() { System.out.println(&quot;Hello again&quot;); } } public static void main(String[] args) { Thread myThread1 = new Thread(new MyRunnable()); myThread1.start(); } } スレッドが取り得る状態 New スレッドが作られて、まだ実行(run)されていない状態。 Runnable スレッドが実行された状態。 Blocked 同期ブロックを実行待ち。(他のスレッドがすでに実行している。) Waiting 他のスレッドを待っている。スレッドシグナリングでWaitingになったり解除されたりする。 競合状態とクリティカルセクション 競合状態はクリティカルセクションで起こりうる状態です。 クリティカルセクション クリティカルセクションとはコードが複数のスレッドで実行されて、その順番によって結果が異なる状態です。複数のスレッドが同じクリティカルセクションに書き込みしようとすると問題が発生します。 public class Counter { protected long count = 0; public void add(long value){ this.count = this.count + value; } } 上記のクラスではaddメソッドがクリティカルセクションになります。 競合状態 上のクリティカルセクションを2つのスレッドAとBで実行されます。まずスレッドAとBがレジスターにthis.count = 0を読み込みます。まずスレッドAが読み込まれたthis.countに2を足します。その後、スレッドBが読み込まれたthis.countに3を足します。この場合、最終的な結果はthis.count = 5ではなく、this.count = 3になります。 上記のように複数のスレッドが同じリソースを取り合うことを競合状態といいます。 競合状態を防ぐ 競合状態を防ぐ一つの方法にはクリティカルセクションを不可分操作(atomic)状態にするというのがあります。つまり、一つのスレッドが実行中には他のスレッドが実行できない状態にします。 これを実現するにはクリティカルセクションでスレッド同期を行います。スレッド同期を行うこと以外ではスレッドロックやjava.util.concurrent.atomic.AtomicIntegerなどの不可分操作変数を使うことができます。 スレッドセーフと共有リソース 複数のスレッドに同時で実行されても安全なコードをスレッドセーフと呼びます。スレッドセーフなコードは競合状態を起こしません。競合状態は複数のスレッドが共有リソースをアクセスすることで起こります、なのでどういったリソースが共有なのかを知っておくことが大切です。 ローカル変数 ローカル変数はスレッドのスタックに保存されるのでスレッド間で共有されることがありません。プリミティブ型のローカル変数は常にスレッドセーフです。 ローカルオブジェクト参照 この場合は、参照自体は共有されません。しかしオブジェクトは共有ヒープに保存されます。もしオブジェクトがローカルで作成されメソッドの外には出ない場合、スレッドセーフです。 メンバ変数 メンバ変数はオブジェクトと共にヒープに保存されています。スレッドセーフではありません。 synchronizedキーワードで同期ブロック Javaの同期ブロックはすべてsynchronizedのメソッド修飾子で実装できます。 public synchronized void add(int value){ this.count += value; } メソッド全体を同期ブロックにするのが好ましくない場合は、一部だけ同期ブロックにすることができます。 public void add(int value){ synchronized(this){ this.count += value; } } 同期ブロックの中のコードは複数のスレッドで同時に実行されることはありません。 volatileキーワード Volatileとは揮発性という意味です。プログラミングにおいては値が変更されていないようにみえてもアクセスする度に変わっているという意味になります。Javaのvolatileキーワードは変数がCPUキャッシュにではなくメインメモリに保存されていることを保証をします。 例えば以下のような共有されている変数があるとします。 public class SharedObject { public int counter = 0; } スレッド1はcounterをインクリメントします。スレッド1とスレッド2は度々counterを読みます。もしcounterがvolatileだと宣言されていない場合は、メインメモリからではなく、CPUキャッシュから値が読まれる恐れがあります。以下の図がこのシチューションを表しています。 出典: Jenkov.com volatileだけでは十分じゃない場合 スレッドがvolatileな変数を読み込んで、それを元に新しい値に更新してしまうと、その変数は固定されるのを保証されません。変数を読み込んで書き込むまでの間に他のスレッドが書き込む可能性があり、競合状態が発生します。 ThreadLocal ThreadLocalクラスは一つのスレッドにしか読み書きできない変数を作るのに使います。もし2つのスレッドが同じThreadLocalの参照を読み込むと2つのスレッドは互いのThreadLocal変数にアクセスできません。 ThreadLocal変数の作成 private ThreadLocal myThreadLocal = new ThreadLocal(); ThreadLocal変数へのアクセス ThreadLocal変数が作成されると以下のように値を設定できます。 myThreadLocal.set(&quot;A thread local value&quot;); 値を読み込むには: String threadLocalValue = (String) myThreadLocal.get(); スレッドシグナリング スレッドシグナリングでスレッド間にシグナルを送ることができます。シグナリングを使えばスレッドが他のスレッドを待機するということができるようになります。 共有オブジェクトでシグナリング 共有変数の値を変更することでスレッド間のシグナリングを行うのが最も簡単です。 public class MySignal{ protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess(){ return this.hasDataToProcess; } public synchronized void setHasDataToProcess(boolean hasData){ this.hasDataToProcess = hasData; } } 出典: Jenkov.com wait() notify() notifyAll() java.lang.Objectにはシグナルを待機しているスレッドを非アクティブ化するメカニズムがあります。wait()をオブジェクトに呼び出すスレッドは他のスレッドがそのオブジェクトがnotify()を実行するまで非アクティブになります。 デッドロック デッドロックとは本来スレッドシグナリングで進行するはずの複数のスレッドがブロック状態(非アクティブ)になっていて、プログラムが動かない状態を指します。簡単な例をあげると、スレッドAとスレッドBがあって、スレッドAがスレッドBをロックしてスレッドBを待機する、スレッドBがスレッドAをロックしてスレッドAを待機する。 生産者消費者問題 並列処理の問題としてよく取り上げられるのが生産者消費者問題です。この問題では、一つのデータ構造から複数の消費者スレッドがアイテムを取り出し、複数の生産者がアイテムを追加します。 データ構造 データ構造は先に入れられたデータから順に取り出されるキューで実装します。 スレッド 消費者スレッドはキューがいっぱいになると生産者スレッドをブロックします。(これ以上商品を足すのを防ぐため。)逆に、生産者スレッドはキューが空になると消費者スレッドをブロックするよう実装します。 これらはいちいちスレッドシグナリングを実行しなくてもjava.util.concurrent.BlockingQueueで簡単に実装できてしまいます。 参照 Jenkov.com Java documentation Winterbe" />
<link rel="canonical" href="http://localhost:4000/programming/java/2019/07/01/java%E4%B8%A6%E5%88%97%E5%8C%96.html" />
<meta property="og:url" content="http://localhost:4000/programming/java/2019/07/01/java%E4%B8%A6%E5%88%97%E5%8C%96.html" />
<meta property="og:site_name" content="RW21 Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-01T22:00:00+10:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/programming/java/2019/07/01/java%E4%B8%A6%E5%88%97%E5%8C%96.html"},"url":"http://localhost:4000/programming/java/2019/07/01/java%E4%B8%A6%E5%88%97%E5%8C%96.html","headline":"Java並列化","dateModified":"2019-07-01T22:00:00+10:00","datePublished":"2019-07-01T22:00:00+10:00","description":"はじめに 本記事ではJavaにおける並列処理を主に個人の備忘録、勉強用として雑に記しています。気が向いたら更新します。主にJavaの並列化に使うキーワードを紹介しています。 並列処理 並列処理とは複数のスレッドを使って、メインスレッドとは別のスレッドでプロセスを行うことである。 並列処理における問題例 スレッドAがメモリを読み込んでいる間にスレッドBがそのメモリに書き込みをしたら、スレッドAで読み取られるのは新しい値か古い値か? 並列(concurrency) vs 並行(parallelism) 並列化と並行化という単語は同じマルチスレッドプログラミングにおいてよく使われますが、同一ではありません。 並列化 システムが複数のタスクを一度にこなすこと。 並行化 タスクがサブタスクに分散して一度に複数のサブタスクをこなすこと。 マルチスレッドプログラミング? 分散コンピューティング? 並行処理? 並列処理? マルチスレッドプログラミングや分散コンピューティングの概念は並列処理の概念とよく似ています。基本的には(並行処理, 並列処理)⊆マルチスレッディングです。本記事では並列処理しか扱いません。 なぜ並列処理するのか リソース利用の最適化 CPUのアイドルタイムを減らす。 プログラムの高速化 例えばサーバーからリクエストをlistenしてそのリクエストを処理するループがあるとする。 while(server is active){ // リクエストを受ける ... // リクエストを処理する } このループではリクエストを処理してる間は他のリクエストを受けれなくなっている。もしリクエストの処理のタスクを他のスレッドに受け渡せば、すぐにまたリクエストを受けれるようになり、高速化できる。 while(server is active){ // リクエストを受ける ... // リクエストを他スレッドに受け渡す } 主な並列処理モデル ここで紹介する並列処理モデルは分散コンピューティングシステムに使われるモデルと共通するのもあります。 Parallel Workers 出典: Jenkov.com Delegatorがworkerにタスクを分散する方法です。Parallel worker モデルは最もJavaの並列処理に使われているモデルです。java.util.concurrentパッケージに含まれているツールはこのモデルに基づいて作られています。 利点/欠点 利点 簡単 欠点 複数のworkerが同じメモリもしくはデータベースを改変している場合、workerスレッドはその改変が他のworkerスレッドにも知らされるようにしなければならない。(CPUの実行に留まらず、メモリにプッシュされなければならない) 競合状態やデッドロックといった並列処理におけるよくある問題を避けなければならない。 -スレッドが同じデータ構造へのアクセスを待ってしまうと並行化(parallelisation)が欠けてします。 タスクの順番が決定的ではない。これにより、現在のシステムのステートがどうなっているのか分からなくなる場合がある。 Assembly Line 出典: Jenkov.com Workerにタスクの役割があって、一つのタスクが終わると次のWorkerにタスクが移行する。 出典: Jenkov.com 上の図のようになることも。 利点/欠点 利点 共有ステートがない。 タスクに順番がある。 欠点 Same-threading シングルスレッドのプログラムを複数のCPUコアを活用するために複数コアに渡ってスケールすること。このモデルでは共有されるデータ構造、メモリはありません。 Javaでスレッドを作る Javaではスレッドはオブジェクトとして扱われています。 public class StartThread { public static void main(String[] args) { Thread myThread = new Thread(); myThread.start(); } } myThread.start();でスレッドを始めています。しかしこれではスレッドは何もしていません。 runメソッドをオーバーライドしてスレッドでコードを動かす スレッドに動くコードを指定するにはThreadのサブクラスを作り、runメソッドをオーバーライドします。 public class StartThread { public static class MyThread extends Thread { @Override public void run() { System.out.println(&quot;Hello World&quot;); } } public static void main(String[] args) { Thread myThread = new MyThread(); myThread.start(); } } Runnableインターフェースでスレッドを実装 Runnableをコンストラクタとして通してスレッドを作ることができます。 public class StartThread { public static class MyRunnable implements Runnable { @Override public void run() { System.out.println(&quot;Hello again&quot;); } } public static void main(String[] args) { Thread myThread1 = new Thread(new MyRunnable()); myThread1.start(); } } スレッドが取り得る状態 New スレッドが作られて、まだ実行(run)されていない状態。 Runnable スレッドが実行された状態。 Blocked 同期ブロックを実行待ち。(他のスレッドがすでに実行している。) Waiting 他のスレッドを待っている。スレッドシグナリングでWaitingになったり解除されたりする。 競合状態とクリティカルセクション 競合状態はクリティカルセクションで起こりうる状態です。 クリティカルセクション クリティカルセクションとはコードが複数のスレッドで実行されて、その順番によって結果が異なる状態です。複数のスレッドが同じクリティカルセクションに書き込みしようとすると問題が発生します。 public class Counter { protected long count = 0; public void add(long value){ this.count = this.count + value; } } 上記のクラスではaddメソッドがクリティカルセクションになります。 競合状態 上のクリティカルセクションを2つのスレッドAとBで実行されます。まずスレッドAとBがレジスターにthis.count = 0を読み込みます。まずスレッドAが読み込まれたthis.countに2を足します。その後、スレッドBが読み込まれたthis.countに3を足します。この場合、最終的な結果はthis.count = 5ではなく、this.count = 3になります。 上記のように複数のスレッドが同じリソースを取り合うことを競合状態といいます。 競合状態を防ぐ 競合状態を防ぐ一つの方法にはクリティカルセクションを不可分操作(atomic)状態にするというのがあります。つまり、一つのスレッドが実行中には他のスレッドが実行できない状態にします。 これを実現するにはクリティカルセクションでスレッド同期を行います。スレッド同期を行うこと以外ではスレッドロックやjava.util.concurrent.atomic.AtomicIntegerなどの不可分操作変数を使うことができます。 スレッドセーフと共有リソース 複数のスレッドに同時で実行されても安全なコードをスレッドセーフと呼びます。スレッドセーフなコードは競合状態を起こしません。競合状態は複数のスレッドが共有リソースをアクセスすることで起こります、なのでどういったリソースが共有なのかを知っておくことが大切です。 ローカル変数 ローカル変数はスレッドのスタックに保存されるのでスレッド間で共有されることがありません。プリミティブ型のローカル変数は常にスレッドセーフです。 ローカルオブジェクト参照 この場合は、参照自体は共有されません。しかしオブジェクトは共有ヒープに保存されます。もしオブジェクトがローカルで作成されメソッドの外には出ない場合、スレッドセーフです。 メンバ変数 メンバ変数はオブジェクトと共にヒープに保存されています。スレッドセーフではありません。 synchronizedキーワードで同期ブロック Javaの同期ブロックはすべてsynchronizedのメソッド修飾子で実装できます。 public synchronized void add(int value){ this.count += value; } メソッド全体を同期ブロックにするのが好ましくない場合は、一部だけ同期ブロックにすることができます。 public void add(int value){ synchronized(this){ this.count += value; } } 同期ブロックの中のコードは複数のスレッドで同時に実行されることはありません。 volatileキーワード Volatileとは揮発性という意味です。プログラミングにおいては値が変更されていないようにみえてもアクセスする度に変わっているという意味になります。Javaのvolatileキーワードは変数がCPUキャッシュにではなくメインメモリに保存されていることを保証をします。 例えば以下のような共有されている変数があるとします。 public class SharedObject { public int counter = 0; } スレッド1はcounterをインクリメントします。スレッド1とスレッド2は度々counterを読みます。もしcounterがvolatileだと宣言されていない場合は、メインメモリからではなく、CPUキャッシュから値が読まれる恐れがあります。以下の図がこのシチューションを表しています。 出典: Jenkov.com volatileだけでは十分じゃない場合 スレッドがvolatileな変数を読み込んで、それを元に新しい値に更新してしまうと、その変数は固定されるのを保証されません。変数を読み込んで書き込むまでの間に他のスレッドが書き込む可能性があり、競合状態が発生します。 ThreadLocal ThreadLocalクラスは一つのスレッドにしか読み書きできない変数を作るのに使います。もし2つのスレッドが同じThreadLocalの参照を読み込むと2つのスレッドは互いのThreadLocal変数にアクセスできません。 ThreadLocal変数の作成 private ThreadLocal myThreadLocal = new ThreadLocal(); ThreadLocal変数へのアクセス ThreadLocal変数が作成されると以下のように値を設定できます。 myThreadLocal.set(&quot;A thread local value&quot;); 値を読み込むには: String threadLocalValue = (String) myThreadLocal.get(); スレッドシグナリング スレッドシグナリングでスレッド間にシグナルを送ることができます。シグナリングを使えばスレッドが他のスレッドを待機するということができるようになります。 共有オブジェクトでシグナリング 共有変数の値を変更することでスレッド間のシグナリングを行うのが最も簡単です。 public class MySignal{ protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess(){ return this.hasDataToProcess; } public synchronized void setHasDataToProcess(boolean hasData){ this.hasDataToProcess = hasData; } } 出典: Jenkov.com wait() notify() notifyAll() java.lang.Objectにはシグナルを待機しているスレッドを非アクティブ化するメカニズムがあります。wait()をオブジェクトに呼び出すスレッドは他のスレッドがそのオブジェクトがnotify()を実行するまで非アクティブになります。 デッドロック デッドロックとは本来スレッドシグナリングで進行するはずの複数のスレッドがブロック状態(非アクティブ)になっていて、プログラムが動かない状態を指します。簡単な例をあげると、スレッドAとスレッドBがあって、スレッドAがスレッドBをロックしてスレッドBを待機する、スレッドBがスレッドAをロックしてスレッドAを待機する。 生産者消費者問題 並列処理の問題としてよく取り上げられるのが生産者消費者問題です。この問題では、一つのデータ構造から複数の消費者スレッドがアイテムを取り出し、複数の生産者がアイテムを追加します。 データ構造 データ構造は先に入れられたデータから順に取り出されるキューで実装します。 スレッド 消費者スレッドはキューがいっぱいになると生産者スレッドをブロックします。(これ以上商品を足すのを防ぐため。)逆に、生産者スレッドはキューが空になると消費者スレッドをブロックするよう実装します。 これらはいちいちスレッドシグナリングを実行しなくてもjava.util.concurrent.BlockingQueueで簡単に実装できてしまいます。 参照 Jenkov.com Java documentation Winterbe","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="RW21 Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">RW21 Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Java並列化</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-01T22:00:00+10:00" itemprop="datePublished">Jul 1, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="はじめに">はじめに</h1>

<p>本記事ではJavaにおける並列処理を主に個人の備忘録、勉強用として雑に記しています。気が向いたら更新します。主にJavaの並列化に使うキーワードを紹介しています。</p>

<h1 id="並列処理">並列処理</h1>

<p>並列処理とは複数のスレッドを使って、メインスレッドとは別のスレッドでプロセスを行うことである。</p>

<h2 id="並列処理における問題例">並列処理における問題例</h2>

<p>スレッドAがメモリを読み込んでいる間にスレッドBがそのメモリに書き込みをしたら、スレッドAで読み取られるのは新しい値か古い値か?</p>

<h2 id="並列concurrency-vs-並行parallelism">並列(concurrency) vs 並行(parallelism)</h2>

<p>並列化と並行化という単語は同じマルチスレッドプログラミングにおいてよく使われますが、同一ではありません。</p>

<h3 id="並列化">並列化</h3>

<p>システムが複数のタスクを一度にこなすこと。</p>

<h3 id="並行化">並行化</h3>

<p>タスクがサブタスクに分散して一度に複数のサブタスクをこなすこと。</p>

<h3 id="マルチスレッドプログラミング-分散コンピューティング-並行処理-並列処理">マルチスレッドプログラミング? 分散コンピューティング? 並行処理? 並列処理?</h3>

<p>マルチスレッドプログラミングや分散コンピューティングの概念は並列処理の概念とよく似ています。基本的には(並行処理, 並列処理)⊆マルチスレッディングです。本記事では並列処理しか扱いません。</p>

<h1 id="なぜ並列処理するのか">なぜ並列処理するのか</h1>

<ul>
  <li>リソース利用の最適化
    <ul>
      <li>CPUのアイドルタイムを減らす。</li>
    </ul>
  </li>
  <li>プログラムの高速化
    <ul>
      <li>例えばサーバーからリクエストをlistenしてそのリクエストを処理するループがあるとする。
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="n">server</span> <span class="n">is</span> <span class="n">active</span><span class="o">){</span>
  <span class="c1">// リクエストを受ける</span>
  <span class="o">...</span>
  <span class="c1">// リクエストを処理する</span>
  <span class="o">}</span>
</code></pre></div>        </div>
        <p>このループではリクエストを処理してる間は他のリクエストを受けれなくなっている。もしリクエストの処理のタスクを他のスレッドに受け渡せば、すぐにまたリクエストを受けれるようになり、高速化できる。</p>
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="n">server</span> <span class="n">is</span> <span class="n">active</span><span class="o">){</span>
  <span class="c1">// リクエストを受ける</span>
  <span class="o">...</span>
  <span class="c1">// リクエストを他スレッドに受け渡す</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h1 id="主な並列処理モデル">主な並列処理モデル</h1>

<p>ここで紹介する並列処理モデルは分散コンピューティングシステムに使われるモデルと共通するのもあります。</p>

<h2 id="parallel-workers">Parallel Workers</h2>

<p><img src="/assets/images/2019/concurrency-models-1.png" alt="" /></p>

<p>出典: <a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities">Jenkov.com</a></p>

<p>Delegatorがworkerにタスクを分散する方法です。Parallel worker モデルは最もJavaの並列処理に使われているモデルです。<code class="highlighter-rouge">java.util.concurrent</code>パッケージに含まれているツールはこのモデルに基づいて作られています。</p>

<h3 id="利点欠点">利点/欠点</h3>

<ul>
  <li>利点
    <ul>
      <li>簡単</li>
    </ul>
  </li>
  <li>欠点
    <ul>
      <li>複数のworkerが同じメモリもしくはデータベースを改変している場合、workerスレッドはその改変が他のworkerスレッドにも知らされるようにしなければならない。(CPUの実行に留まらず、メモリにプッシュされなければならない)</li>
      <li><a href="#競合状態とクリティカルセクション">競合状態</a>やデッドロックといった並列処理におけるよくある問題を避けなければならない。
  -スレッドが同じデータ構造へのアクセスを待ってしまうと並行化(parallelisation)が欠けてします。</li>
      <li>タスクの順番が決定的ではない。これにより、現在のシステムのステートがどうなっているのか分からなくなる場合がある。</li>
    </ul>
  </li>
</ul>

<h2 id="assembly-line">Assembly Line</h2>

<p><img src="/assets/images/2019/concurrency-models-3.png" alt="" /></p>

<p>出典: <a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities">Jenkov.com</a></p>

<p>Workerにタスクの役割があって、一つのタスクが終わると次のWorkerにタスクが移行する。</p>

<p><img src="images/concurrency-models-6.png" alt="" />
<img src="/assets/images/2019/concurrency-models-6.png" alt="" /></p>

<p>出典: <a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities">Jenkov.com</a></p>

<p>上の図のようになることも。</p>

<h3 id="利点欠点-1">利点/欠点</h3>

<ul>
  <li>利点
    <ul>
      <li>共有ステートがない。</li>
      <li>タスクに順番がある。</li>
    </ul>
  </li>
  <li>欠点</li>
</ul>

<h2 id="same-threading">Same-threading</h2>

<p>シングルスレッドのプログラムを複数のCPUコアを活用するために複数コアに渡ってスケールすること。このモデルでは共有されるデータ構造、メモリはありません。</p>

<h1 id="javaでスレッドを作る">Javaでスレッドを作る</h1>

<p>Javaではスレッドはオブジェクトとして扱われています。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartThread</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">myThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">();</span>
        <span class="n">myThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">myThread.start();</code>でスレッドを始めています。しかしこれではスレッドは何もしていません。</p>

<h2 id="runメソッドをオーバーライドしてスレッドでコードを動かす"><code class="highlighter-rouge">run</code>メソッドをオーバーライドしてスレッドでコードを動かす</h2>

<p>スレッドに動くコードを指定するには<code class="highlighter-rouge">Thread</code>のサブクラスを作り、<code class="highlighter-rouge">run</code>メソッドをオーバーライドします。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartThread</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">myThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>

        <span class="n">myThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="runnableインターフェースでスレッドを実装"><code class="highlighter-rouge">Runnable</code>インターフェースでスレッドを実装</h2>

<p><code class="highlighter-rouge">Runnable</code>をコンストラクタとして通してスレッドを作ることができます。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartThread</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello again"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">myThread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">MyRunnable</span><span class="o">());</span>

        <span class="n">myThread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="スレッドが取り得る状態">スレッドが取り得る状態</h2>

<ul>
  <li>New
    <ul>
      <li>スレッドが作られて、まだ実行(<code class="highlighter-rouge">run</code>)されていない状態。</li>
    </ul>
  </li>
  <li>Runnable
    <ul>
      <li>スレッドが実行された状態。</li>
    </ul>
  </li>
  <li>Blocked
    <ul>
      <li>同期ブロックを実行待ち。(他のスレッドがすでに実行している。)</li>
    </ul>
  </li>
  <li>Waiting
    <ul>
      <li>他のスレッドを待っている。<a href="#スレッドシグナリング">スレッドシグナリング</a>でWaitingになったり解除されたりする。</li>
    </ul>
  </li>
</ul>

<h1 id="競合状態とクリティカルセクション">競合状態とクリティカルセクション</h1>

<p>競合状態はクリティカルセクションで起こりうる状態です。</p>

<h2 id="クリティカルセクション">クリティカルセクション</h2>

<p>クリティカルセクションとはコードが複数のスレッドで実行されて、その順番によって結果が異なる状態です。複数のスレッドが同じクリティカルセクションに書き込みしようとすると問題が発生します。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>

     <span class="kd">protected</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">){</span>
         <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
     <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>上記のクラスでは<code class="highlighter-rouge">add</code>メソッドがクリティカルセクションになります。</p>

<h2 id="競合状態">競合状態</h2>

<p>上のクリティカルセクションを2つのスレッドAとBで実行されます。まずスレッドAとBがレジスターに<code class="highlighter-rouge">this.count = 0</code>を読み込みます。まずスレッドAが読み込まれた<code class="highlighter-rouge">this.count</code>に2を足します。その後、スレッドBが読み込まれた<code class="highlighter-rouge">this.count</code>に3を足します。この場合、最終的な結果は<code class="highlighter-rouge">this.count = 5</code>ではなく、<code class="highlighter-rouge">this.count = 3</code>になります。</p>

<p>上記のように複数のスレッドが同じリソースを取り合うことを競合状態といいます。</p>

<h2 id="競合状態を防ぐ">競合状態を防ぐ</h2>

<p>競合状態を防ぐ一つの方法にはクリティカルセクションを不可分操作(atomic)状態にするというのがあります。つまり、一つのスレッドが実行中には他のスレッドが実行できない状態にします。</p>

<p>これを実現するにはクリティカルセクションでスレッド同期を行います。スレッド同期を行うこと以外ではスレッドロックや<code class="highlighter-rouge">java.util.concurrent.atomic.AtomicInteger</code>などの不可分操作変数を使うことができます。</p>

<h1 id="スレッドセーフと共有リソース">スレッドセーフと共有リソース</h1>

<p>複数のスレッドに同時で実行されても安全なコードをスレッドセーフと呼びます。スレッドセーフなコードは競合状態を起こしません。競合状態は複数のスレッドが共有リソースをアクセスすることで起こります、なのでどういったリソースが共有なのかを知っておくことが大切です。</p>

<h2 id="ローカル変数">ローカル変数</h2>

<p>ローカル変数はスレッドのスタックに保存されるのでスレッド間で共有されることがありません。プリミティブ型のローカル変数は常にスレッドセーフです。</p>

<h2 id="ローカルオブジェクト参照">ローカルオブジェクト参照</h2>

<p>この場合は、参照自体は共有されません。しかしオブジェクトは共有ヒープに保存されます。もしオブジェクトがローカルで作成されメソッドの外には出ない場合、スレッドセーフです。</p>

<h2 id="メンバ変数">メンバ変数</h2>

<p>メンバ変数はオブジェクトと共にヒープに保存されています。スレッドセーフではありません。</p>

<h1 id="synchronizedキーワードで同期ブロック"><code class="highlighter-rouge">synchronized</code>キーワードで同期ブロック</h1>

<p>Javaの同期ブロックはすべて<code class="highlighter-rouge">synchronized</code>のメソッド修飾子で実装できます。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>メソッド全体を同期ブロックにするのが好ましくない場合は、一部だけ同期ブロックにすることができます。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>

    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
       <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">value</span><span class="o">;</span>   
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>同期ブロックの中のコードは複数のスレッドで同時に実行されることはありません。</p>

<h1 id="volatileキーワード"><code class="highlighter-rouge">volatile</code>キーワード</h1>

<p>Volatileとは揮発性という意味です。プログラミングにおいては値が変更されていないようにみえてもアクセスする度に変わっているという意味になります。Javaの<code class="highlighter-rouge">volatile</code>キーワードは変数がCPUキャッシュにではなくメインメモリに保存されていることを保証をします。</p>

<p>例えば以下のような共有されている変数があるとします。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SharedObject</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>スレッド1は<code class="highlighter-rouge">counter</code>をインクリメントします。スレッド1とスレッド2は度々<code class="highlighter-rouge">counter</code>を読みます。もし<code class="highlighter-rouge">counter</code>が<code class="highlighter-rouge">volatile</code>だと宣言されていない場合は、メインメモリからではなく、CPUキャッシュから値が読まれる恐れがあります。以下の図がこのシチューションを表しています。</p>

<p><img src="/assets/images/2019/java-volatile-2.png" alt="" /></p>

<p>出典: <a href="http://tutorials.jenkov.com/java-concurrency/volatile.html">Jenkov.com</a></p>

<h2 id="volatileだけでは十分じゃない場合"><code class="highlighter-rouge">volatile</code>だけでは十分じゃない場合</h2>

<p>スレッドが<code class="highlighter-rouge">volatile</code>な変数を読み込んで、それを元に新しい値に更新してしまうと、その変数は固定されるのを保証されません。変数を読み込んで書き込むまでの間に他のスレッドが書き込む可能性があり、競合状態が発生します。</p>

<h1 id="threadlocal"><code class="highlighter-rouge">ThreadLocal</code></h1>

<p><code class="highlighter-rouge">ThreadLocal</code>クラスは一つのスレッドにしか読み書きできない変数を作るのに使います。もし2つのスレッドが同じ<code class="highlighter-rouge">ThreadLocal</code>の参照を読み込むと2つのスレッドは互いの<code class="highlighter-rouge">ThreadLocal</code>変数にアクセスできません。</p>

<h2 id="threadlocal変数の作成"><code class="highlighter-rouge">ThreadLocal</code>変数の作成</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">ThreadLocal</span> <span class="n">myThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadLocal</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="threadlocal変数へのアクセス"><code class="highlighter-rouge">ThreadLocal</code>変数へのアクセス</h2>

<p><code class="highlighter-rouge">ThreadLocal</code>変数が作成されると以下のように値を設定できます。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"A thread local value"</span><span class="o">);</span>
</code></pre></div></div>

<p>値を読み込むには:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">threadLocalValue</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">myThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<h1 id="スレッドシグナリング">スレッドシグナリング</h1>

<p>スレッドシグナリングでスレッド間にシグナルを送ることができます。シグナリングを使えばスレッドが他のスレッドを待機するということができるようになります。</p>

<h2 id="共有オブジェクトでシグナリング">共有オブジェクトでシグナリング</h2>

<p>共有変数の値を変更することでスレッド間のシグナリングを行うのが最も簡単です。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MySignal</span><span class="o">{</span>

  <span class="kd">protected</span> <span class="kt">boolean</span> <span class="n">hasDataToProcess</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">hasDataToProcess</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">hasDataToProcess</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">setHasDataToProcess</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">hasData</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">hasDataToProcess</span> <span class="o">=</span> <span class="n">hasData</span><span class="o">;</span>  
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>出典: <a href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html">Jenkov.com</a></p>

<h2 id="wait-notify-notifyall"><code class="highlighter-rouge">wait()</code> <code class="highlighter-rouge">notify()</code> <code class="highlighter-rouge">notifyAll()</code></h2>

<p><code class="highlighter-rouge">java.lang.Object</code>にはシグナルを待機しているスレッドを非アクティブ化するメカニズムがあります。<code class="highlighter-rouge">wait()</code>をオブジェクトに呼び出すスレッドは他のスレッドがそのオブジェクトが<code class="highlighter-rouge">notify()</code>を実行するまで非アクティブになります。</p>

<h1 id="デッドロック">デッドロック</h1>

<p>デッドロックとは本来スレッドシグナリングで進行するはずの複数のスレッドがブロック状態(非アクティブ)になっていて、プログラムが動かない状態を指します。簡単な例をあげると、スレッドAとスレッドBがあって、スレッドAがスレッドBをロックしてスレッドBを待機する、スレッドBがスレッドAをロックしてスレッドAを待機する。</p>

<h1 id="生産者消費者問題">生産者消費者問題</h1>

<p>並列処理の問題としてよく取り上げられるのが生産者消費者問題です。この問題では、一つのデータ構造から複数の消費者スレッドがアイテムを取り出し、複数の生産者がアイテムを追加します。</p>

<h2 id="データ構造">データ構造</h2>

<p>データ構造は先に入れられたデータから順に取り出されるキューで実装します。</p>

<h2 id="スレッド">スレッド</h2>

<p>消費者スレッドはキューがいっぱいになると生産者スレッドをブロックします。(これ以上商品を足すのを防ぐため。)逆に、生産者スレッドはキューが空になると消費者スレッドをブロックするよう実装します。</p>

<p>これらはいちいちスレッドシグナリングを実行しなくても<code class="highlighter-rouge">java.util.concurrent.BlockingQueue</code>で簡単に実装できてしまいます。</p>

<p><img src="/assets/images/2019/producer_consumer.jpg" alt="" /></p>

<h1 id="参照">参照</h1>

<ul>
  <li><a href="http://tutorials.jenkov.com/java-concurrency/index.html">Jenkov.com</a></li>
  <li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/">Java documentation</a></li>
  <li><a href="https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/">Winterbe</a></li>
</ul>


  </div><a class="u-url" href="/programming/java/2019/07/01/java%E4%B8%A6%E5%88%97%E5%8C%96.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">RW21 Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">RW21 Blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/RW21"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">RW21</span></a></li><li><a href="https://www.twitter.com/RinzeWatanabe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">RinzeWatanabe</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>RW21 blog. 雑多なブログ.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
