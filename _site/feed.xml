<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-04T16:00:02+10:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">RW21 Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">無向グラフをクローンする</title><link href="http://localhost:4000/programming/%E7%84%A1%E5%90%91%E3%82%B0%E3%83%A9%E3%83%95%E3%82%92%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%B3%E3%81%99%E3%82%8B/" rel="alternate" type="text/html" title="無向グラフをクローンする" /><published>2019-08-01T22:00:00+10:00</published><updated>2019-08-01T22:00:00+10:00</updated><id>http://localhost:4000/programming/%E7%84%A1%E5%90%91%E3%82%B0%E3%83%A9%E3%83%95%E3%82%92%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%B3%E3%81%99%E3%82%8B</id><content type="html" xml:base="http://localhost:4000/programming/%E7%84%A1%E5%90%91%E3%82%B0%E3%83%A9%E3%83%95%E3%82%92%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%B3%E3%81%99%E3%82%8B/">&lt;h1 id=&quot;無向グラフとは&quot;&gt;無向グラフとは&lt;/h1&gt;

&lt;p&gt;無向グラフのデータ構造のクローンは簡単そうに見えて意外と簡単にはできません。下手に実装すると大変効率の悪いプログラムになってしまいます。&lt;/p&gt;

&lt;p&gt;本記事ではクローンしたいグラフのノードの一つを入力にとって、それと同じグラフを持つ入力されたノードのコピーを返す関数を作ります。&lt;/p&gt;

&lt;h2 id=&quot;有向グラフ無向グラフ&quot;&gt;有向グラフ/無向グラフ&lt;/h2&gt;

&lt;p&gt;グラフには有向グラフと無向グラフがあり、無向グラフはノードとノードの間の辺が対面通行のグラフです。有向グラフはノード間の辺が一方通行のグラフです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/undirected_directed_graph.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出典: &lt;a href=&quot;https://www.e-education.psu.edu/geog597i_02/node/832&quot;&gt;e-education.psu.edu&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ノードの定義&quot;&gt;ノードの定義&lt;/h2&gt;

&lt;p&gt;まず、ノードを以下のように定義します。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Python&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;使用するアルゴリズムとデータ構造&quot;&gt;使用するアルゴリズムとデータ構造&lt;/h1&gt;

&lt;p&gt;データ構造をクローンするにはまずそのデータ構造を走査する必要があります。例えば二次元配列のクローンをするには必ず全ての要素を走査します。グラフのようなデータ構造を走査するアルゴリズムにはBFS(幅優先探索)とDFS(深さ優先探索)というのがあります。グラフのデータ構造は深さより幅が大きいことを想定して、ここではBFSを使います。しかし、BFSでグラフを探索しただけではノード間の辺の関係を記録することは難しいです。そこで、ハッシュテーブルを使います。&lt;/p&gt;

&lt;h2 id=&quot;bfs&quot;&gt;BFS&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根ノードを空のキューに加える。&lt;/li&gt;
  &lt;li&gt;ノードをキューの先頭から取り出し、以下の処理を行う。
    &lt;ul&gt;
      &lt;li&gt;ノードが探索対象であれば、探索をやめ結果を返す。&lt;/li&gt;
      &lt;li&gt;そうでない場合、ノードの子で未探索のものを全てキューに追加する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;もしキューが空ならば、グラフ内の全てのノードに対して処理が行われたので、探索をやめ”not found”と結果を返す。&lt;/li&gt;
  &lt;li&gt;2に戻る。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;出典: &lt;a href=&quot;https://ja.wikipedia.org/wiki/%E5%B9%85%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2&quot;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ハッシュテーブル&quot;&gt;ハッシュテーブル&lt;/h2&gt;

&lt;p&gt;皆大好きな万能データ構造のハッシュテーブルです。難しいアルゴリズムの問題ではとりあえずハッシュテーブルを使おうとしますね。この問題ではハッシュテーブルはオリジナルのノードをキー、コピーを値として保存します。&lt;/p&gt;

&lt;h1 id=&quot;アルゴリズム&quot;&gt;アルゴリズム&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;入力されたノードをキューに追加し、ノードをキー、ノードのコピーを値としてハッシュテーブルに保存する。このクローニングはキューが空になるまで続けます。&lt;/li&gt;
  &lt;li&gt;ノードをキューから取得する。&lt;/li&gt;
  &lt;li&gt;取得したノードに隣接したノード(&lt;code class=&quot;highlighter-rouge&quot;&gt;node.neighbors&lt;/code&gt;)をイテレートする。&lt;/li&gt;
  &lt;li&gt;隣接しているノードがハッシュテーブルにない場合は、そのノードのコピーをハッシュテーブルに追加し、そのノードをキューに追加する。&lt;/li&gt;
  &lt;li&gt;クローンされた隣接のノードを取得したノードの&lt;code class=&quot;highlighter-rouge&quot;&gt;neighbors&lt;/code&gt;として追加する。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;pythonコード&quot;&gt;Pythonコード&lt;/h2&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cloneGraph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 入力されたノードのクローン&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copy_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;

        &lt;span class=&quot;c&quot;&gt;# キューとハッシュテーブルの作成&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy_node&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
                
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy_node&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;時間計算量空間計算量&quot;&gt;時間計算量/空間計算量&lt;/h2&gt;

&lt;p&gt;時間計算量 = O(ノードの数 + 辺の数)&lt;/p&gt;

&lt;p&gt;空間計算量 = O(ノードの数 + 辺の数)&lt;/p&gt;</content><author><name>RW</name></author><category term="data_structure" /><category term="algorithm" /><summary type="html">BFSとハッシュテーブルを使った無向グラフのクローン。</summary></entry><entry><title type="html">素数の並びからeが⁉</title><link href="http://localhost:4000/maths/e-from-prime/" rel="alternate" type="text/html" title="素数の並びからeが⁉" /><published>2019-07-13T22:00:00+10:00</published><updated>2019-07-13T22:00:00+10:00</updated><id>http://localhost:4000/maths/%20e%20from%20prime</id><content type="html" xml:base="http://localhost:4000/maths/e-from-prime/">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;p&gt;素数を素数の間(&lt;script type=&quot;math/tex&quot;&gt;P_{n+1}- P_{1}&lt;/script&gt;)が増加するように並べ続けたときの列の項の平均が
&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;に収束する(かもしれない)という投稿を&lt;a href=&quot;https://www.reddit.com/r/math/comments/cbd0a7/found_e_in_the_primes_maybe/&quot;&gt;Reddit&lt;/a&gt;の\r\maths板で見つけた。&lt;/p&gt;

&lt;h1 id=&quot;どういうこと&quot;&gt;どういうこと?&lt;/h1&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;3,5,7,11,13&lt;/script&gt;は素数の間隔が&lt;script type=&quot;math/tex&quot;&gt;2,2,3,2&lt;/script&gt;というように増加してないからノーカウント。&lt;script type=&quot;math/tex&quot;&gt;19,23,29&lt;/script&gt;はOK。このような素数の並びの項の合計の平均は&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;に収束するかも?という投稿。以下は977までの素数までの平均。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 3 5 -&amp;gt; 3
7 11 -&amp;gt; 2
13 17 -&amp;gt; 2 
19 23 29
31 37
41 43 47 53
59 61 67
71 73 79
83 89 97
101 103 107
109 113 127
131 137
139 149
151 157
163 167 173
...
857 859 863 877
881 883 887 907
911 919 929
953 967
971 977

Total average value of each row: 163 / 60 = 2.71666... ≈ e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出典: &lt;a href=&quot;https://www.reddit.com/r/math/comments/cbd0a7/found_e_in_the_primes_maybe/&quot;&gt;reddit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まさかと思ってコメントを見てみたら、ここでネタバレしますけど、この数列は&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;に収束してなかった。&lt;/p&gt;

&lt;h1 id=&quot;なぜこうなるのか&quot;&gt;なぜこうなるのか&lt;/h1&gt;

&lt;p&gt;違いも数もランダムな列で上のように平均をとると、&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;に収束する。上のような素数の数列はある程度違いも数もランダムな列と類似する。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;a_i&lt;/script&gt;をランダムな数の数列で&lt;script type=&quot;math/tex&quot;&gt;a_{n+1} - a_{n}&lt;/script&gt;を独立同分布でランダムな連続確立変数とする。上のように違いが増加するような数列だけをとると、列に項が2つある確率が&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;、3つある確率が&lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt;、4つある確率が&lt;script type=&quot;math/tex&quot;&gt;1/6&lt;/script&gt;、5つある確率が&lt;script type=&quot;math/tex&quot;&gt;1/24&lt;/script&gt;…という風な数列になる。&lt;/p&gt;

&lt;p&gt;この数列の合計は&lt;script type=&quot;math/tex&quot;&gt;\sum_{k=0}^{\infty} \frac{1}{k!} = e&lt;/script&gt;となる。&lt;/p&gt;

&lt;h2 id=&quot;素数の並びはランダムではない&quot;&gt;素数の並びはランダムではない&lt;/h2&gt;

&lt;p&gt;素数の平均の数列が&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;に収束しないということは、つまり素数の並びは完全にランダムではないといえるのではないだろうか?&lt;/p&gt;</content><author><name>RW</name></author><category term="number_theory" /><summary type="html">そんなわけなかった。</summary></entry><entry><title type="html">Java並列化</title><link href="http://localhost:4000/programming/java%E4%B8%A6%E5%88%97%E5%8C%96/" rel="alternate" type="text/html" title="Java並列化" /><published>2019-07-09T22:00:00+10:00</published><updated>2019-07-09T22:00:00+10:00</updated><id>http://localhost:4000/programming/%20java%E4%B8%A6%E5%88%97%E5%8C%96</id><content type="html" xml:base="http://localhost:4000/programming/java%E4%B8%A6%E5%88%97%E5%8C%96/">&lt;h1 id=&quot;はじめに&quot;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;本記事ではJavaにおける並列処理を主に個人の備忘録、勉強用として雑に記しています。気が向いたら更新します。主にJavaの並列化に使うキーワードを紹介しています。&lt;/p&gt;

&lt;h1 id=&quot;並列処理&quot;&gt;並列処理&lt;/h1&gt;

&lt;p&gt;並列処理とは複数のスレッドを使って、メインスレッドとは別のスレッドでプロセスを行うことである。&lt;/p&gt;

&lt;h2 id=&quot;並列処理における問題例&quot;&gt;並列処理における問題例&lt;/h2&gt;

&lt;p&gt;スレッドAがメモリを読み込んでいる間にスレッドBがそのメモリに書き込みをしたら、スレッドAで読み取られるのは新しい値か古い値か?&lt;/p&gt;

&lt;h2 id=&quot;並列concurrency-vs-並行parallelism&quot;&gt;並列(concurrency) vs 並行(parallelism)&lt;/h2&gt;

&lt;p&gt;並列化と並行化という単語は同じマルチスレッドプログラミングにおいてよく使われますが、同一ではありません。&lt;/p&gt;

&lt;h3 id=&quot;並列化&quot;&gt;並列化&lt;/h3&gt;

&lt;p&gt;システムが複数のタスクを一度にこなすこと。&lt;/p&gt;

&lt;h3 id=&quot;並行化&quot;&gt;並行化&lt;/h3&gt;

&lt;p&gt;タスクがサブタスクに分散して一度に複数のサブタスクをこなすこと。&lt;/p&gt;

&lt;h3 id=&quot;マルチスレッドプログラミング-分散コンピューティング-並行処理-並列処理&quot;&gt;マルチスレッドプログラミング? 分散コンピューティング? 並行処理? 並列処理?&lt;/h3&gt;

&lt;p&gt;マルチスレッドプログラミングや分散コンピューティングの概念は並列処理の概念とよく似ています。基本的には(並行処理, 並列処理)⊆マルチスレッディングです。本記事では並列処理しか扱いません。&lt;/p&gt;

&lt;h1 id=&quot;なぜ並列処理するのか&quot;&gt;なぜ並列処理するのか&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;リソース利用の最適化
    &lt;ul&gt;
      &lt;li&gt;CPUのアイドルタイムを減らす。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;プログラムの高速化
    &lt;ul&gt;
      &lt;li&gt;例えばサーバーからリクエストをlistenしてそのリクエストを処理するループがあるとする。
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// リクエストを受ける&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// リクエストを処理する&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;このループではリクエストを処理してる間は他のリクエストを受けれなくなっている。もしリクエストの処理のタスクを他のスレッドに受け渡せば、すぐにまたリクエストを受けれるようになり、高速化できる。&lt;/p&gt;
        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// リクエストを受ける&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// リクエストを他スレッドに受け渡す&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;主な並列処理モデル&quot;&gt;主な並列処理モデル&lt;/h1&gt;

&lt;p&gt;ここで紹介する並列処理モデルは分散コンピューティングシステムに使われるモデルと共通するのもあります。&lt;/p&gt;

&lt;h2 id=&quot;parallel-workers&quot;&gt;Parallel Workers&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/concurrency-models-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出典: &lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Delegatorがworkerにタスクを分散する方法です。Parallel worker モデルは最もJavaの並列処理に使われているモデルです。&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt;パッケージに含まれているツールはこのモデルに基づいて作られています。&lt;/p&gt;

&lt;h3 id=&quot;利点欠点&quot;&gt;利点/欠点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;利点
    &lt;ul&gt;
      &lt;li&gt;簡単&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;欠点
    &lt;ul&gt;
      &lt;li&gt;複数のworkerが同じメモリもしくはデータベースを改変している場合、workerスレッドはその改変が他のworkerスレッドにも知らされるようにしなければならない。(CPUの実行に留まらず、メモリにプッシュされなければならない)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#競合状態とクリティカルセクション&quot;&gt;競合状態&lt;/a&gt;やデッドロックといった並列処理におけるよくある問題を避けなければならない。
  -スレッドが同じデータ構造へのアクセスを待ってしまうと並行化(parallelisation)が欠けてします。&lt;/li&gt;
      &lt;li&gt;タスクの順番が決定的ではない。これにより、現在のシステムのステートがどうなっているのか分からなくなる場合がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assembly-line&quot;&gt;Assembly Line&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/concurrency-models-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出典: &lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Workerにタスクの役割があって、一つのタスクが終わると次のWorkerにタスクが移行する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/concurrency-models-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出典: &lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html#concurrency-models-and-distributed-system-similarities&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上の図のようになることも。&lt;/p&gt;

&lt;h3 id=&quot;利点欠点-1&quot;&gt;利点/欠点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;利点
    &lt;ul&gt;
      &lt;li&gt;共有ステートがない。&lt;/li&gt;
      &lt;li&gt;タスクに順番がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;欠点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;same-threading&quot;&gt;Same-threading&lt;/h2&gt;

&lt;p&gt;シングルスレッドのプログラムを複数のCPUコアを活用するために複数コアに渡ってスケールすること。このモデルでは共有されるデータ構造、メモリはありません。&lt;/p&gt;

&lt;h1 id=&quot;javaでスレッドを作る&quot;&gt;Javaでスレッドを作る&lt;/h1&gt;

&lt;p&gt;Javaではスレッドはオブジェクトとして扱われています。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StartThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;myThread.start();&lt;/code&gt;でスレッドを始めています。しかしこれではスレッドは何もしていません。&lt;/p&gt;

&lt;h2 id=&quot;runメソッドをオーバーライドしてスレッドでコードを動かす&quot;&gt;runメソッドをオーバーライドしてスレッドでコードを動かす&lt;/h2&gt;

&lt;p&gt;スレッドに動くコードを指定するには&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;のサブクラスを作り、&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;メソッドをオーバーライドします。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StartThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;runnableインターフェースでスレッドを実装&quot;&gt;Runnableインターフェースでスレッドを実装&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;をコンストラクタとして通してスレッドを作ることができます。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StartThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRunnable&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello again&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyRunnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;myThread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;スレッドが取り得る状態&quot;&gt;スレッドが取り得る状態&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;New
    &lt;ul&gt;
      &lt;li&gt;スレッドが作られて、まだ実行(&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;)されていない状態。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Runnable
    &lt;ul&gt;
      &lt;li&gt;スレッドが実行された状態。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Blocked
    &lt;ul&gt;
      &lt;li&gt;同期ブロックを実行待ち。(他のスレッドがすでに実行している。)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Waiting
    &lt;ul&gt;
      &lt;li&gt;他のスレッドを待っている。&lt;a href=&quot;#スレッドシグナリング&quot;&gt;スレッドシグナリング&lt;/a&gt;でWaitingになったり解除されたりする。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dead
    &lt;ul&gt;
      &lt;li&gt;スレッドが実行し終えると死にます。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;競合状態とクリティカルセクション&quot;&gt;競合状態とクリティカルセクション&lt;/h1&gt;

&lt;p&gt;競合状態はクリティカルセクションで起こりうる状態です。&lt;/p&gt;

&lt;h2 id=&quot;クリティカルセクション&quot;&gt;クリティカルセクション&lt;/h2&gt;

&lt;p&gt;クリティカルセクションとはコードが複数のスレッドで実行されて、その順番によって結果が異なる状態です。複数のスレッドが同じクリティカルセクションに書き込みしようとすると問題が発生します。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

     &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上記のクラスでは&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;メソッドがクリティカルセクションになります。&lt;/p&gt;

&lt;h2 id=&quot;競合状態&quot;&gt;競合状態&lt;/h2&gt;

&lt;p&gt;上のクリティカルセクションを2つのスレッドAとBで実行されます。まずスレッドAとBがレジスターに&lt;code class=&quot;highlighter-rouge&quot;&gt;this.count = 0&lt;/code&gt;を読み込みます。まずスレッドAが読み込まれた&lt;code class=&quot;highlighter-rouge&quot;&gt;this.count&lt;/code&gt;に2を足します。その後、スレッドBが読み込まれた&lt;code class=&quot;highlighter-rouge&quot;&gt;this.count&lt;/code&gt;に3を足します。この場合、最終的な結果は&lt;code class=&quot;highlighter-rouge&quot;&gt;this.count = 5&lt;/code&gt;ではなく、&lt;code class=&quot;highlighter-rouge&quot;&gt;this.count = 3&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;上記のように複数のスレッドが同じリソースを取り合うことを競合状態といいます。&lt;/p&gt;

&lt;h2 id=&quot;競合状態を防ぐ&quot;&gt;競合状態を防ぐ&lt;/h2&gt;

&lt;p&gt;競合状態を防ぐ一つの方法にはクリティカルセクションを不可分操作(atomic)状態にするというのがあります。つまり、一つのスレッドが実行中には他のスレッドが実行できない状態にします。&lt;/p&gt;

&lt;p&gt;これを実現するにはクリティカルセクションでスレッド同期を行います。スレッド同期を行うこと以外ではスレッドロックや&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent.atomic.AtomicInteger&lt;/code&gt;などの不可分操作変数を使うことができます。&lt;/p&gt;

&lt;h1 id=&quot;スレッドセーフと共有リソース&quot;&gt;スレッドセーフと共有リソース&lt;/h1&gt;

&lt;p&gt;複数のスレッドに同時で実行されても安全なコードをスレッドセーフと呼びます。スレッドセーフなコードは競合状態を起こしません。競合状態は複数のスレッドが共有リソースをアクセスすることで起こります、なのでどういったリソースが共有なのかを知っておくことが大切です。&lt;/p&gt;

&lt;h2 id=&quot;ローカル変数&quot;&gt;ローカル変数&lt;/h2&gt;

&lt;p&gt;ローカル変数はスレッドのスタックに保存されるのでスレッド間で共有されることがありません。プリミティブ型のローカル変数は常にスレッドセーフです。&lt;/p&gt;

&lt;h2 id=&quot;ローカルオブジェクト参照&quot;&gt;ローカルオブジェクト参照&lt;/h2&gt;

&lt;p&gt;この場合は、参照自体は共有されません。しかしオブジェクトは共有ヒープに保存されます。もしオブジェクトがローカルで作成されメソッドの外には出ない場合、スレッドセーフです。&lt;/p&gt;

&lt;h2 id=&quot;メンバ変数&quot;&gt;メンバ変数&lt;/h2&gt;

&lt;p&gt;メンバ変数はオブジェクトと共にヒープに保存されています。スレッドセーフではありません。&lt;/p&gt;

&lt;h1 id=&quot;synchronizedキーワードで同期ブロック&quot;&gt;synchronizedキーワードで同期ブロック&lt;/h1&gt;

&lt;p&gt;Javaの同期ブロックはすべて&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;のメソッド修飾子で実装できます。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;メソッド全体を同期ブロックにするのが好ましくない場合は、一部だけ同期ブロックにすることができます。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同期ブロックの中のコードは複数のスレッドで同時に実行されることはありません。&lt;/p&gt;

&lt;h1 id=&quot;volatileキーワード&quot;&gt;volatileキーワード&lt;/h1&gt;

&lt;p&gt;Volatileとは揮発性という意味です。プログラミングにおいては値が変更されていないようにみえてもアクセスする度に変わっているという意味になります。Javaの&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;キーワードは変数がCPUキャッシュにではなくメインメモリに保存されていることを保証をします。&lt;/p&gt;

&lt;p&gt;例えば以下のような共有されている変数があるとします。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharedObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;スレッド1は&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;をインクリメントします。スレッド1とスレッド2は度々&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;を読みます。もし&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;が&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;だと宣言されていない場合は、メインメモリからではなく、CPUキャッシュから値が読まれる恐れがあります。以下の図がこのシチューションを表しています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/java-volatile-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出典: &lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/volatile.html&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;volatileだけでは十分じゃない場合&quot;&gt;volatileだけでは十分じゃない場合&lt;/h2&gt;

&lt;p&gt;スレッドが&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;な変数を読み込んで、それを元に新しい値に更新してしまうと、その変数は固定されるのを保証されません。変数を読み込んで書き込むまでの間に他のスレッドが書き込む可能性があり、競合状態が発生します。&lt;/p&gt;

&lt;h1 id=&quot;threadlocal&quot;&gt;ThreadLocal&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;クラスは一つのスレッドにしか読み書きできない変数を作るのに使います。もし2つのスレッドが同じ&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;の参照を読み込むと2つのスレッドは互いの&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;変数にアクセスできません。&lt;/p&gt;

&lt;h2 id=&quot;threadlocal変数の作成&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;変数の作成&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThreadLocal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;threadlocal変数へのアクセス&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;変数へのアクセス&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;変数が作成されると以下のように値を設定できます。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;myThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A thread local value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;値を読み込むには:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadLocalValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;スレッドシグナリング&quot;&gt;スレッドシグナリング&lt;/h1&gt;

&lt;p&gt;スレッドシグナリングでスレッド間にシグナルを送ることができます。シグナリングを使えばスレッドが他のスレッドを待機するということができるようになります。&lt;/p&gt;

&lt;h2 id=&quot;共有オブジェクトでシグナリング&quot;&gt;共有オブジェクトでシグナリング&lt;/h2&gt;

&lt;p&gt;共有変数の値を変更することでスレッド間のシグナリングを行うのが最も簡単です。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySignal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasDataToProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasDataToProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasDataToProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setHasDataToProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasDataToProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出典: &lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/thread-signaling.html&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;wait-notify-notifyall&quot;&gt;wait() notify() notifyAll()&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;にはシグナルを待機しているスレッドを非アクティブ化するメカニズムがあります。&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;をオブジェクトに呼び出すスレッドは他のスレッドがそのオブジェクトが&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;を実行するまで非アクティブになります。&lt;/p&gt;

&lt;h1 id=&quot;デッドロック&quot;&gt;デッドロック&lt;/h1&gt;

&lt;p&gt;デッドロックとは本来スレッドシグナリングで進行するはずの複数のスレッドがブロック状態(非アクティブ)になっていて、プログラムが動かない状態を指します。簡単な例をあげると、スレッドAとスレッドBがあって、スレッドAがスレッドBをロックしてスレッドBを待機する、スレッドBがスレッドAをロックしてスレッドAを待機する。&lt;/p&gt;

&lt;h1 id=&quot;スレッド優先順位&quot;&gt;スレッド優先順位&lt;/h1&gt;

&lt;p&gt;スレッドの優先順位は&lt;code class=&quot;highlighter-rouge&quot;&gt;setPriority&lt;/code&gt;で設定できます。設定が高いほうが先に実行されます。優先順位には1から10までintが使えます。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StartThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上の場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;myThread&lt;/code&gt;が先に実行されます。&lt;/p&gt;

&lt;h1 id=&quot;join&quot;&gt;join&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;メソッドでスレッドが終わるまで他のスレッドが実行されないよう保証します。&lt;code class=&quot;highlighter-rouge&quot;&gt;thread1.join()&lt;/code&gt;でthread1が実行中の時、thread1が実行を終えるまで他のスレッドを実行しません。イメージとしては、スレッド同士をつなげたいときに使います。&lt;/p&gt;

&lt;h1 id=&quot;生産者消費者問題&quot;&gt;生産者消費者問題&lt;/h1&gt;

&lt;p&gt;並列処理の問題としてよく取り上げられるのが生産者消費者問題です。この問題では、一つのデータ構造から複数の消費者スレッドがアイテムを取り出し、複数の生産者がアイテムを追加します。&lt;/p&gt;

&lt;h2 id=&quot;データ構造&quot;&gt;データ構造&lt;/h2&gt;

&lt;p&gt;データ構造は先に入れられたデータから順に取り出されるキューで実装します。&lt;/p&gt;

&lt;h2 id=&quot;スレッド&quot;&gt;スレッド&lt;/h2&gt;

&lt;p&gt;消費者スレッドはキューがいっぱいになると生産者スレッドをブロックします。(これ以上商品を足すのを防ぐため。)逆に、生産者スレッドはキューが空になると消費者スレッドをブロックするよう実装します。&lt;/p&gt;

&lt;p&gt;これらはいちいちスレッドシグナリングを実行しなくても&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent.BlockingQueue&lt;/code&gt;で簡単に実装できてしまいます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019/producer_consumer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;参照&quot;&gt;参照&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/index.html&quot;&gt;Jenkov.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/&quot;&gt;Java documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/&quot;&gt;Winterbe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>RW</name></author><category term="Java" /><summary type="html">Javaの並列化について。</summary></entry><entry><title type="html">ブログを始める</title><link href="http://localhost:4000/personal/%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AA%E3%81%A9/" rel="alternate" type="text/html" title="ブログを始める" /><published>2019-06-25T22:00:00+10:00</published><updated>2019-06-25T22:00:00+10:00</updated><id>http://localhost:4000/personal/%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AA%E3%81%A9</id><content type="html" xml:base="http://localhost:4000/personal/%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AA%E3%81%A9/">&lt;p&gt;Jenkyllでブログを始めることにした。ブログとはいっても個人的な備忘録などが中心になると思う。以下、ありきたりなブログの初投稿。&lt;/p&gt;

&lt;h1 id=&quot;jenkyll&quot;&gt;Jenkyll&lt;/h1&gt;
&lt;p&gt;静的サイトジェネレーターのJenkyllとGithubPagesを使った。Jenkyllで色々なテーマを漁ったが自分にしっくり来るものがなかった。自分がブログに求めるのはカテゴリ分けと過去の投稿を簡単に振り返られるブログだがこれに合うテーマはなかなかない。(静的サイトだと難しいのだろう。)&lt;/p&gt;

&lt;h1 id=&quot;読者&quot;&gt;読者&lt;/h1&gt;
&lt;p&gt;このブログでは読者を想定しないであくまでも自分のためにブログを書こうと思う。他人の目を気にしてしまうとブログを書くのが億劫になるからだ。自分が毎日書いている日記を公開しないのは多分人の目が億劫だからかもしれない、もちろん自分の心情を晒しだしたくないという理由もあるが。&lt;/p&gt;

&lt;h1 id=&quot;頻度&quot;&gt;頻度&lt;/h1&gt;
&lt;p&gt;最低でも月イチの投稿を維持したい。&lt;/p&gt;</content><author><name>RW</name></author></entry></feed>